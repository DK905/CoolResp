# CoolResp или "хватит пытать себя расписанием".
Мечтают ли андроиды об электроовцах? Мечтаете ли вы об удобном расписании? Если да, то с этим может помочь CoolResp - программа для преобразования расписания от учебного отдела УрТИСИ СибГУТИ в читабельный вид.
Она ещё не совершенна: изредка бывают проблемы в кабинетах, дизайн заставляет вспомнить школьные годы, а сам код - чудовищная абберрация из грязнейших костылей и тёмной магии эльфийских регулярных выражений, автора которой хочется прибить ссылкой на PEP8. Но несмотря на это, конвертер был отлажен на двадцати наборах тестовых данных, и уже сейчас показывает отличные результаты: всего за пару секунд он делает расписание читаемым и понятным, а возможность выбрать свои подгруппы - это же то самое, о чём мечтает почти каждый первокурсник.
Из-за множества косяков в изначальных расписаниях, итог преобразования лучше проверять - модули парсинга и анализа отсеивают подавляющее большинство ошибок, но ведь всегда может появиться новое и необычное исключение. В таких случаях, нужно либо поменять исходный файл расписания, либо отправить тикет в [специальный раздел](https://github.com/DK905/CoolResp/issues), описав там проблему и приложив к описанию расписание.

## Приступая к работе.
Есть два варианта начала работы с CoolResp:
1) Скачать и открыть исполняемый файл, который запустит готовый к работе конвертер;
2) Загрузить проект из папки CResp, установить зависимости (Qt5, pyexcel, openpyxl, pyperclip), изменить всё под себя, запустить. В этом случае, полезно будет знать назначение отдельных модулей:

## Навигация по интерфейсу.


## В разработке.


## Как это устроено.
Чтобы конвертер не казался чёрным ящиком, магически обрабатывающим расписание, далее будет приведено описание идеи преобразования, на примере случая "когда обрабатывается нормальный файл расписания". Надеюсь, оно поможет тем, кто когда-нибудь решит улучшить сей проект.
### 1) Считывание
Общая схема считывания такова: считывание файла -> выбор нужного листа -> выбор нужной группы -> выделение ячеек расписания, относящихся к выбранной группе.
Для считывания, используется модуль pyexcel - он позволяет взаимодействовать как со старым форматом .xls, так и с новым .xlsx, считывая их в определённый объект (здесь это orderedDict).
После выбора листа, программа ищет строку с группами (в этой строке, первая ячейка всегда называется "дни"), попутно находя ячейку с периодом расписания, и определяя начало "расписательной" части листа (то есть той части, которая и содержит информацию о парах). 
Затем, составляется база разбора - примитивная аппликация ячеек с информацией о парах выбранной группы. Структура базы разбора подробно расписана в документации к модулю считывания.
### 2) Парсинг
Этап парсинга - самый важный этап: на нём вычленяется вся логическая информация для каждого уникального вида пары. Уникальным видом здесь считается комбинация "день - номер пары - предмет - препод - тип пары - подгруппа". Без парсера, работа программы просто невозможно, но из-за особенностей исходного расписания, парсинг здесь превращается в ядрёную проблему: стабильность работы под вопросом (всегда ведь может появиться новый тип синтаксического косяка), да и коррекция ошибок убивает всю читаемость кода (чего стоит одна только регулярка на 300+ символов).
Сам процесс парсинга состоит в последовательном вычленении необходимой информации из информационной ячейки. Такая ячейка, в нашем расписании, имеет множество синтаксических ошибок и разных шаблонов порядка записи разных элементов. Однако, существуют и закономерности: предмет всегда начинается только с большой буквы, у препода есть инициалы и т.п.
В процессе парсинга, синтаксические ошибки устраняются самыми разными проверками и ухищрениями, вроде той же регулярки на 300+ символов.
Из известных проблем парсинга, пока что можно выделить только хромую логику логического разброса кабинетов - в проекте реализована лишь её примерная версия, т.к для полноценной нужно выделить закономерности в ~шестиста наборах правильного распределения. Но и в текущем виде она работает почти идеально - за все тесты было обнаружено лишь десять ошибок такого характера.
### 3) Анализ
Если этап парсинга успешно завершился, то базу парсинга можно спокойно анализировать.
Цель анализа заключается сразу в двух важных задачах:
- [ ] Определить количество подгрупп для каждого типа пары каждого предмета;
- [ ] Найти все случаи неправильной записи типа пары (когда одну из лаб по запаре назвали практикой и т.п).
### 4) Форматирование
Когда расписание запарсенно и проанализировано, с ним можно делать любые вещи - исследовать на соответствие учебному плану, ужаснуться количеству пар, или сохранить его в читаемой форме.
Для последнего, используется модуль openpyxl - хоть он и работает только с современным форматом .xlsx, его преимущество заключается в колоссальном количестве возможностей для форматирования сохранённых данных.
В процессе форматирования, конвертер объединяет и украшает всё что нужно объединить и украсить, после чего расписание может быть сохранено.

Для подробного описания лучше почитать документацию и комментарии к модулям, но первичное представление может быть получено и по этому скромному гайду.
