""" Информация о модуле
Данный модуль предназначен для считывания изначального файла расписания (в формате xls или xlsx),
и последующего вычленения из него расписания конкретной выбранной группы.

Первоначальное считывание идёт через pyexcel, так как данный модуль лучше всего справляется с данной задачей.
openpyxl мог бы быть удобнее для данной задачи, но он поддерживает только xlsx.

Известные баги:
    1) Если в строке с группами (шапка подтаблицы расписания) будет несколько одинаковых групп,
       то, при выборе одной из них, всегда будет выбираться только первая.

"""

# Импорт функции для считывания EXCEL таблицы
from pyexcel import get_book_dict as pxl_book

# Импорт базовых команд поиска и замены из стандартного модуля регулярных выражений
from re import findall, fullmatch, match, search, split, sub


""" Ошибка для выделения критичных косяков в исходных данных
Описание:
    Пользовательский класс ошибки.
    Используется только в этом модуле, т.к на нормальном файле включается коррекция ошибок.

Аргументы:
    Некий текст, обозначающий "что не так"

Возвращаемое:
    Текст из аргумента

"""
class BadDataError(Exception):
    def __init__(self, text):
        self.txt = text


""" функция для считывания книги xls/xlsx в специальный словарь из pyexcel
Аргументы:
    Путь к файлу таблицы расписания

Возвращаемое:
    Объект книги в формате типизированного словаря

"""
def read_book(book):
    # Если открывается файл
    if search(r'(?m)\.xlsx?$', book):
        return pxl_book(file_name = book)
    # Если открывается таблица из вк
    elif search(r'(?m)^https?', book):
        pass
    # Если открывается не пойми что, дропнуть ошибку
    else:
        return BadDataError('Ошибка! ЭТО нельзя обработать приличными способами!')


""" Функция для отображения листов в книге
Аргументы:
    Типизированный словарь из read_book

Возвращаемое:
    Список листов книги (для меню выбора листов)

"""
def choise_sheet(d_book):
    if list(d_book.keys()):
        return(list(d_book.keys()))
    else:
        return BadDataError('Нет листов - нет расписания')


""" Функция для выделения нужной информации
Аргументы:
    Типизированный словарь из read_book

Возвращаемое:
    Элементный список.
    [1] Период расписания
    [2] Год обучения
    [3] Список групп на листе
    [4] Индекс начала расписательной части

"""
def choise_group(sheet):
    timey_wimey = year = grp_list = start = None
    for r_ind, row in enumerate(sheet):
        # Найти период расписания, если ещё не найден
        if not timey_wimey:
            for col in row:
                if search(r'[Нн]а\s*период', col):
                    # Выделение периода расписания. Если он указан неправильно, потом будут проблемы
                    timey_wimey = findall(r'с\s*([\d.]{5,8})[г.]*\s*по\s*([\d.]{5,8})[г.]*', col)[0]
                    # Выделение года
                    year = 2000 + int(timey_wimey[0][-2:])
                    break
        # Найти список групп и начальную позицию
        if not grp_list and search(r'(?m)^[Дд]ни', row[0]):
            # Отсеивание пустых столбцов
            grp_list = [el for el in row if el]
            grp_list = [grp_list[i] for i in range(2, len(grp_list), 2)]
            start = r_ind
            break
        # Если всё найдено, продолжать поиск не нужно
        if timey_wimey and grp_list:
            break
    if timey_wimey and grp_list:
        return [timey_wimey, year, grp_list, start]
    else:
        return BadDataError('А расписание-то ненастоящее! Нет периода или групп!')


"""                 Начальная стадия разбора расписания

Данная стадия предполагает подготовку расписания выбранной группы к препарированию.
Сначала, среди всех листов и всех групп выбирается одна конкретная группа, для которой
вычленяется собственная таблица расписания, которая в процессе частично форматируется.
По итогу стадии, будет создана первичная БД обработки

"""

""" Функция корректного считывания объединённых ячеек
Описание:
    Используется в процессе работы функции prepare

Аргументы:
    1) Текущая строка
    2) Текущий столбец

Возвращаемое:
    1) Если ячейка объединённая, то её значение
    2) Если нет, то пустую запись

"""
def merged_cells(row, col):
    act = col - 2
    # Если есть предмет и правый сосед не кабинет - ячейка общая
    if row[act] and not row[act+1]:
        return row[act]
    # Если ячейка 100% не общая или строка пройдена - вернуть пустую запись
    elif row[act+1] or act == 2 and not row[act]:
        return ''
    else:
        return merged_cells(row, act)

""" Функция удаления пустых столбцов на листе
Описание:
    Вызов происходит внутри функции prepare

Аргументы:
    Лист, на котором нужно удалить пустые столбцы

Возвращаемое:
    Лист с удалёнными пустыми столбцами

"""
def exterminate(sheet):
    sheet = list(zip(*sheet))
    sheet = [rs for rs in sheet if any(rs)]
    sheet = [list(row) for row in zip(*sheet)]
    return sheet


""" Функция определения столбца группы
Описание:
    Вызов происходит внутри функции prepare

Аргументы:
    1) Шапка подтаблицы с расписанием
    2) Выбранная группа

Возвращаемое:
    1) Если выбранная группа найдена, то её позицию в строке
    2) Если нет, ошибка

"""
def what_col(title, group):
    for ind, rec in enumerate(title):
        if rec == group:
            return ind
    return BadDataError('Что за шутки? Такой группы нет на листе')


""" Функции форматирования ячеек со специальной инфой
repl_a нужна для начальной замены (до разделения кабинетов)
repl_b нужна для замен при формировании списка кабинетов
swap_quiz нужна для замены зачётов и дифов на коды (иначе они могут мешать при парсинге)

"""
def repl_a(cab):
    # Единый формат для актового зала
    cab = sub(r'[аА].*?[лЛ]', 'АКТ_зал', cab)
    # Кабинет для ФЗК может разнообразно мимикрировать: "с/з, т/з", "1xx УК№1 с/з, т/з", "1xx УК№1"
    pat_zal = r'(?:с\s*?/\s*?з.*?т\s*?/\s*?з)|(?:1[\d]{2}\s*?[уУ][кК]\s*?№\s*?1[,;: ].*т\s*?/\s*?з)|(?:1[\d]{2}\s*?[уУ][кК]\s*?№\s*?1)'
    cab = sub(pat_zal, 'ФЗК_зал,', cab)
    cab = sub(r'с.+?об', '', cab)
    cab = sub(r'\n+', ' ; ', cab)
    cab = sub(r'\s+', ' ', cab)
    return cab

def repl_b(cab, sepr):
    cab = sub(r'[.;: ]', '', cab)
    # Если кабинеты записываются в полной форме
    if not sepr:
        cab = sub(r'[уУ][кК]?№', ' УК№', cab)
    else:
        cab = sub(r'\s*УК№\d', '', cab)
    return cab

def swap_quiz(inf_cell):
    pattern_dif = r'(?i)(?:зач[её]т[\s]*с[\s]*оценкой)|(?:диф[.\s]*зач[её]т)' # Отлов дифов
    pattern_zac = r'(?i)зач[её]т' # Отлов зачётов
    inf_cell = sub(r'\s+', ' ', inf_cell) # Пробельная чистка
    if search(pattern_dif, inf_cell): # Замена дифов на 6D6D6D6
        inf_cell = sub(pattern_dif, '6D6D6D6', inf_cell)
    if search(pattern_zac, inf_cell): # Замена зачётов на 7Z7Z7Z7
        inf_cell = sub(pattern_zac, '7Z7Z7Z7', inf_cell)
    return inf_cell

""" Функция для подготовки расписания выбранной подгруппы к препарированию
Аргументы:
    1) Выбранный лист
    2) Выбранная группа
    3) Индекс строки, с которой начинается конкретно расписание
    4) Константный словарь сокращённых записей дней
    5) Флаг для сокращения кабинетов

Возвращаемое:
    База обработки.

    Структура элемента базы обработки:
    [0] - день недели в форматной записи
    [1] - номер пары
    [2] - ячейка с инфой по предметам, преподам, подгруппам, типам пар, датам
    [3] - список кабинетов для [2]

"""
def prepare(sheet, group, start, days, dv_yn):
    trash = [] # БД разбора

    # Расписание всегда идёт вплоть до "начальник УО"
    for i in range(start+1, len(sheet)+1):
        finita = [a for a in sheet[i] if search(r'(?i)начальник\s*уо', str(a))]
        if finita:
            end = i-1
            break

    sheet = sheet[start : end] # Первичная БД

    if '' in sheet[0]:             # Если в шапке есть пустые значения, то в таблице могут быть пустые столбцы...
        sheet = exterminate(sheet) # ...а пустые столбцы = штука, которая усложняет обработку
    g = what_col(sheet[0], group)  # Определение столбца с инфой для выбранной группы
    sheet = sheet[1:]              # Обрезка расписательной таблицы по шапке

    # Регулярный шаблон для выбора дня недели (на случай, если где-то его нет)
    days_pat = r'(?i)(.*л.*)|(.*в.*о.*к.*)|(.*с.*д.*)|(.*ч.*г.*)|(.*я.*)|(.*у.*б.*)'   

    for row in sheet:
        """ Выделение конкретных частей новой записи в БД """
        # День недели
        if not row[0]: # День - общая ячейка, то есть значение есть только в левой верхней ячейке
            day = trash[-1][0] # Следовательно, для общей ячейки, день берётся из предыдущей записи
        else: # Но если день есть, то его нужно определить и привести к общему виду
             for ind_d, sovp in enumerate(findall(days_pat, row[0])[0]):
                if sovp:
                    day = days[ind_d]
                    break

        # Номер пары
        num = row[1]

        # Ячейка с инфой о паре
        if row[g] or row[g-1]: # Если инфа лежит не где-то в левой части объединённой ячейки
            info = swap_quiz(row[g])
        elif g > 2:
            info = swap_quiz(merged_cells(row, g))
        else:
            info = ''

        # Кабинеты
        if row[g+1]:
            cabs = repl_a(row[g+1])
            cabs = [repl_b(cb, dv_yn) for cb in split(r'[;,]', cabs)
                    if not fullmatch(r'[.,:; ]*', cb)]
            if not dv_yn:
                # Исправление ['210', '212 УК№1', '329', '331 УК№5', '410 УК№1'] в полных записях
                for ind_cb in range(len(cabs)-1, -1, -1):
                    if match(r'\d+', cabs[ind_cb]) and not match(r'\d+ УК№\d', cabs[ind_cb]):
                        if search(r' УК№\d', cabs[ind_cb+1]):
                            cabs[ind_cb] += search(r' УК№\d', cabs[ind_cb+1])[0]
                        else:
                            cabs[ind_cb] += ' УК№?'
        else:
            cabs = []

        # Запись в БД
        trash.append([day, num, info, cabs])

    return trash
