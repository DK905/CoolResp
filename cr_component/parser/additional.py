r"""Библиотека побочных функций проекта.

    1. Функции для взаимодействия с файлами
    - check_file_extension() : выделение расширения файла
    - check_file_extension() : выделение расширения объектного представления файла
    2. Функции для взаимодействия с JSON
    - json_to_dataframe() : загрузка результатов парсинга из JSON
    - dataframe_to_json() : сохранение результатов парсинга в JSON
    3. Функции для стандартизации данных
    - string_float_to_string_int() : приведение float-числа в int-строку
    - use_standard()     : стандартизация датафрейма
    - create_name()      : формирование стандартного названия для файла расписания
    - format_item_name() : стандартизация столбца предметов
    - format_teacher()   : стандартизация столбца преподавателей
    - format_pdgr()      : стандартизация столбца подгрупп
    - format_cab()       : стандартизация столбца кабинетов
    4. Побочные функции для взаимодействия с запарсенными данными
    - take_data()      : выборка расписания для определённых подгрупп
    - take_time()      : определение периода расписания
    - df_differences() : определение разницы между датафреймами расписания (для тестов)
    - replace_type()   : замена типа данных по словарю
    - find_bad_type()  : исправление ошибочно указанных типов пар

"""

from CoolRespProject.modules_api import api_defaults as api_def
import CoolRespProject.modules_parser.cr_defaults as crd
import pandas as pd
import numpy as np
import os
import re


""" Функции для взаимодействия с файлами """


def check_file_extension(file_path: 'Путь к файлу'
                         ) -> 'Расширение файла':
    """ Функция для опознавания фактического расширения файла на диске """

    # Открыть файл
    with open(file_path, 'rb') as file:
        # Считать из файла байты, соответствующие расширению (в 16-ричной системе)
        ext = file.read(3).hex()
        # Если считанные байты опознаны как поддерживаемое расширение, вернуть его
        # Если расширение не поддерживается, вернуть специальную строку
        ext = api_def.EXTENSIONS[ext] if ext in api_def.EXTENSIONS else api_def.EXTENSIONS['404']
        return ext


def check_object_extension(file: 'Объект файла'
                           ) -> 'Расширение файла':
    """ Функция для опознавания фактического расширения файла, считанного в память """

    # Считать из объекта байты, соответствующие расширению (в 16-ричной системе)
    ext = file[:3].hex()
    # Если считанные байты опознаны как поддерживаемое расширение, вернуть его
    # Если расширение не поддерживается, вернуть специальную строку
    ext = api_def.EXTENSIONS[ext] if ext in api_def.EXTENSIONS else api_def.EXTENSIONS['404']
    return ext


""" Функции для взаимодействия с JSON """


def json_to_dataframe(path_load: 'Путь к сохранённому датафрейму расписания',
                      name:      'Имя датафрейма' = ''
                      ) -> 'Датафрейм БД':
    """ Функция загрузки базы данных расписания из JSON """

    # Считывание датафрейма из файла JSON
    df = pd.read_json(path_load)

    # Применение технической стандартизации к датафрейму
    df = use_standard(df)

    # Добавление названия группы
    if not name:
        name = create_name(df)
    df.name = name

    return df


def dataframe_to_json(df:  'Датафрейм запарсенного расписания, сохраняемый в JSON',
                      ps:  'Путь к каталогу сохранения файла' = None,
                      name: 'Произвольное имя файла' = None
                      ) -> 'JSON-объект или None':
    """ Функция сохранения базы данных в JSON """

    # Если нужно вернуть объект, вместо имени обязательно указывается None
    if not ps:
        name = None
    # Если датафрейм нужно сохранить файлом, но название не указано - сгенерировать его
    elif not name:
        name = os.path.join(ps, f'{create_name(df)}.json')
    else:
        name = os.path.join(ps, name)

    # Преобразование в JSON
    return df.to_json(path_or_buf=name,   # Имя сохраняемого файла ИЛИ преобразуемый объект
                      orient='records',   # Стиль JSON файла
                      indent=4,           # Уровень отступов внутри файла
                      force_ascii=False,  # Запись в ASCII?
                      date_format='iso')  # Формат записи даты


""" Функции для стандартизации данных """


def string_float_to_string_int(some_string: 'Строка, которая может являться float-числом'
                               ) -> 'Строка, содержащая строку или int-версию float-числа':
    """ Функция для перевода строчного представления float-числа в int, если это не иная строка """

    # xlrd считывает числовые строки (такие как «881») в float формате (как «881.0»), что противоречит обработке
    group = re.search(r'^(\d+)', str(some_string))
    group = group[0] if group else some_string

    return group


def use_standard(df:  'Датафрейм базы данных расписания'
                 ) -> 'Модифицированный датафрейм':

    """ Функция применения некоторых технических стандартов к БД """

    # Раскрыть списки в столбце дат на отдельные записи дат
    df = df.explode('date_pair')

    # Заменить текстовое nan на пропуски (почему-то его порой в текст переводит)
    df.replace(to_replace='nan', value=np.nan, inplace=True)

    # Удаление повторов
    df = df.drop_duplicates()

    # Сброс индексации
    df = df.reset_index(drop=True)

    # Заполнить все пропуски в кабинетах значением по умолчанию
    df['cab'] = df['cab'].fillna(crd.DEF_CABS)

    # Предметы, из-за особенностей отлова, могут ловить лишние пробелы по сторонам
    df['item_name'] = df['item_name'].map(lambda item_name: item_name.strip())

    # Изменение типов данных
    # Дни недели - это строго упорядоченные категории, имеющие ценность
    df['day'] = df['day'].astype(pd.CategoricalDtype(crd.DAYS_NAMES,  # Список категорий = дни
                                                     ordered=True))   # Упорядоченность = да

    # Номера пар логичнее записывать в целочисленном формате
    df['num'] = df['num'].astype('int8')

    # Типов пар мало, и каждый из них представляет свою категорию
    df['type'] = df['type'].astype('category')

    # Подгрупп тоже мало, и они тоже формируют категории
    df['pdgr'] = df['pdgr'].astype('category')

    # Даты должны храниться в формате дат, для применения к ним датировочных операций
    df['date_pair'] = df['date_pair'].astype('datetime64')

    return df


def create_name(df:  'Датафрейм базы данных расписания',
                ) -> 'Оптимальное название':

    """ Функция для создания оптимального названия расписания """

    # Текстовое форматирование периода расписания
    time = ' - '.join(d.strftime('%d.%m.%Y') if d is not np.nan else '' for d in take_time(df))

    # Имя датафрейма
    try:
        # Попытаться взять группу из названия датафрейма
        group = df.name
    except:
        # Если названия нет, взять версию по умолчанию
        group = crd.DEF_NAME

    name = f'Респа для {group} на [{time}]'
    return name


def format_item_name(item_name: 'Строка форматируемого предмета'
                     ) -> 'Сокращённая запись предмета':

    """ Функция сокращения предмета """

    # Если название предмета состоит из нескольких слов
    if re.search(r'\b\s\b', item_name):
        # Вернуть аббревиатуру предмета (НИИЧАВО)
        return re.sub(r'\W',
                      '',
                      re.sub(r'(\b[А-ЯЁа-яё])([а-яё]{2,})',
                             lambda m: m[1].upper(),
                             re.sub(r'[()]',
                                    '',
                                    item_name)))

    # Если название предмета однословное, то предмет не нуждается в сокращении
    else:
        return item_name


def format_teacher(teacher: 'Строка форматируемого препода'
                   ) -> 'ФИО препода без должности':

    """ Функция сокращения препода """

    # Регулярный шаблон для поиска должности
    reg_teacher_rank = r'(?m)^([а-яё. \d]+)\s'

    # Удаление должности
    teacher = re.sub(reg_teacher_rank, '', teacher)

    return teacher


def format_pdgr(pdgr: 'Строка форматируемой подгруппы'
                ) -> 'Подгруппа с добавленным обозначением подгруппы':

    """ Функция форматирования подгруппы """

    # Если подгруппа - не значение по умолчанию
    if pdgr != crd.DEF_GROUPS:
        # То добавить к строке обозначение подгруппы
        pdgr = f'{pdgr} п/гр'

    return pdgr


def format_cab(cab: 'Строка сокращаемого кабинета'
               ) -> 'Кабинет без учебного корпуса':

    """ Функция сокращения кабинета """

    # Регулярный шаблон учебного корпуса
    reg_cab_campus = r'\s*[уУ][кК]?№\d'

    # Удаление учебного корпуса
    cab = re.sub(reg_cab_campus, '', str(cab))

    return cab


""" Побочные функции для взаимодействия с запарсенными данными """


def take_data(df:  'БД с запарсенной инфой',
              g2:  'Выбор подгруппы для типов пары с двумя подгруппами',
              g3:  'Выбор подгруппы для типов пары с тремя подгруппами',
              ) -> 'Выборка расписания для нужных подгрупп':

    """ Функция формирования выборки расписания для нужных подгрупп """

    # Формирование словаря выбранных подгрупп
    my_grps = {a[0]: (a[1] if not a[1] in [0, '0'] else
                      crd.DEF_GROUPS) for a in {0: 0,   # 0 подгрупп: общая пара
                                                1: 0,   # 1 подгруппа: плохие исходные данные
                                                2: g2,  # 2 подгруппы: замена на выбор g2
                                                3: g3   # 3 подгруппы: замена на выбор g3
                                                }.items()}

    # Функция для определения числа подгрупп у связки "предмет - тип пары"
    count_groups = lambda vals: len([g for g in set(vals) if g != crd.DEF_GROUPS])
    # Сборка датафрейма числа подгрупп у каждого предмета
    a_bd = pd.DataFrame(df.groupby(['item_name', 'type'], observed=True)['pdgr'].apply(count_groups))
    # Приведение индексации и столбцов к нужному виду
    a_bd = a_bd.reset_index().rename(columns={'pdgr': 'grps'})

    # Не оптимальный способ создания выборки. В будущем, нужно заменить на один запрос

    # Добавление к каждой записи поля числа подгрупп у связки "предмет - тип пары"
    # Замена максимального числа подгрупп на свою подгруппу, согласно словарю
    df_merge = df.merge(a_bd, how='left').replace({'grps': my_grps})
    # Получить все записи, где подгруппа стоит по умолчанию, или соответствует выбранной
    # Убрать столбец своей подгруппы и сбросить индексацию
    # Запрос нужно будет переделать - умолчание повторяется дважды
    df_merge = df_merge.query('(pdgr == @crd.DEF_GROUPS) | (grps == @crd.DEF_GROUPS) | (pdgr == grps)').drop('grps', axis=1).reset_index(drop=True)

    # Вернуть выборку расписания для нужных подгрупп
    return df_merge


def take_time(df:  'Датафрейм базы данных расписания'
              ) -> 'Даты начала и окончания расписания':

    """ Функция получения реального периода расписания """

    # Начало расписания
    date_min = df['date_pair'].dropna().min()
    # Конец расписания
    date_max = df['date_pair'].dropna().max()

    return date_min, date_max


def df_differences(df1: 'Датафрейм №1',
                   df2: 'Датафрейм №2'
                   ) -> 'Сводный датафрейм различий':

    """ Функция для получения сводного датафрейма различия между двумя БД """

    # Объединение результатов
    df_difference = df1.merge(df2, how='outer', indicator=True)

    # Оставить только отличающиеся записи
    df_difference = df_difference[df_difference['_merge'] != 'both']
    
    return df_difference


def replace_type(df:  'БД с запарсенной инфой',
                 rp:  'Словарь замен'
                 ) -> 'БД с исправлениями по словарю замен':

    """ Функция замены кривых типов пары в базе парсинга """

    if not rp:
        return df

    # Проход по всем предметам в словаре замен
    for item_name in rp.keys():
        # Проход по связкам "на замену - заменитель" в типах пары
        for type_old, type_new in rp[item_name].items():
            # Замена по столбцу типов пары, где совпадают предмет и заменяемый тип пары
            df['type'].where(~((df['item_name'] == item_name) & (df['type'] == type_old)),
                             other=type_new,  # Замена на значение заменителя
                             inplace=True)    # Замена проводится сразу в датафрейме

    return df


def find_bad_type(parse: 'БД с запарсенной инфой'
                  ) -> 'Словарь замен кривых типов пар {предмет: {тип пары: замена}}':

    """ Функция поиска неправильных типов пар.
    Под поиском неправильных типов пар здесь подразумевается отлов и предложение замен, вроде ситуации, когда
    при составлении расписания были ошибки (у 1-й и 3-й подгруппы есть только практики, а у 2-й - только лабы)
    """
    
    # Инициализация результирующего словаря
    a_res = {}

    # Составление основы начальной базы анализа подгрупп
    a_bd = parse.query('pdgr != @crd.DEF_GROUPS').groupby(['item_name',
                                                           'type'], observed=True)['pdgr'].apply(lambda v: list(set(v)))

    # Если в базе парсинга не было записей с подгруппами, анализировать нечего
    if a_bd.shape[0] == 0:
        return None
    
    # Преобразование основы базы анализа в упорядоченную мультииндексную структуру
    a_bd = a_bd.reset_index().set_index(['item_name', 'type'])
    
    for item_name, data_0 in a_bd.groupby(level=0):
        # Если в типе пары лишь одна подгруппа, то он не может быть заменителем
        if data_0.shape[0] <= 1:
            continue

        # Распределение набора подгрупп на хорошие и плохие
        good, bad = {}, {}

        # Оптимальнее делать циклом по каждому атомарному набору
        for item_type, data_1 in data_0.groupby(level=1):
            # Список подгрупп задаётся как отсортированная последовательность
            groups = sorted(map(int, data_1.values[0][0]))
            # Если всё хорошо, то она будет представлять собой целый ряд от 1 до max
            if groups == list(range(1, max(groups) + 1)):
                good[item_type] = groups
            # Если тип пары с косяками (пропуски в ряде подгрупп), то он может быть ошибкой
            else:
                bad[item_type] = groups
        
        # Если у предмета есть косячные типы пар, то их надо заменить в базе данных
        # Но ещё нужно иметь нормальные типы пар
        if bad and good:
            # Создать словарь замен
            shapeshifters = {}
            
            # Словарь замен заполняется с погружением на 2 итерации (поиск лучшего варианта замены)
            # Заполнение идёт итерациями, а не отдельно для каждого типа пары во имя оптимизации
            for i in range(2):
                # Если словарь замен заполнен, то прекратить итерирование
                if len(shapeshifters) == len(bad):
                    break
                
                # Нужно отыскать заменитель для каждого плохого типа пары
                for bad_type, bad_vals in bad.items():
                    # Если у плохого типа пары уже есть заменитель, перейти к следующем
                    if bad_type in shapeshifters:
                        continue
                    
                    # Максимальный номер подгруппы
                    bad_max = max(bad_vals)
                    # Заменитель и его максимальный номер подгруппы
                    good_shift, good_max = None, 0
                    
                    # Заменители ищутся в хороших типах пары
                    for act_type, act_vals in good.items():
                        # Если после первой итерации заменитель был найден, то использовать его
                        if i == 1 and good_shift:
                            break
                        
                        # Максимальная подгруппа текущего заменителя
                        act_max = max(act_vals)
                        # 1) Найти для плохиша такой заменитель, чей максимум не будет меньше
                        if i == 0 and act_max >= bad_max > good_max:
                            good_shift, good_max = act_type, act_max
                        # 2) Если замена не нашлась, поставить первый попавшийся хороший тип
                        elif i == 1 and act_max > good_max:
                            good_shift, good_max = act_type, act_max
                    
                    # Если у плохого типа пары появился заменитель, добавить его в словарь
                    if good_shift:
                        shapeshifters[bad_type] = good_shift

            # Если у предмета есть список замен, добавить его как значение в словаре анализа
            if shapeshifters:
                a_res[item_name] = shapeshifters

    # Если словарь анализа был составлен, вернуть его
    return a_res
